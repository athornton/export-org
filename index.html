<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Org-mode export to Reveal.js and PDF</title>
<meta name="author" content="Adam Thornton"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js/dist/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./css/local.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdn.jsdelivr.net/npm/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Org-mode export to Reveal.js and PDF</h1><p class="subtitle"></p>
<h2 class="author">Adam Thornton</h2><p class="date">Created: 2025-09-17 Wed 01:00</p>
</section>
<section>
<section id="slide-org2750d23">
<h2 id="org2750d23">Org-mode export to Reveal.js and PDF</h2>
<p>
If you're me, you think better in a text editor than in Powerpoint.
</p>

<p>
A few years ago I ran across <a href="https://github.com/yjwen/org-reveal">org-reveal</a>.  It was revelatory.
</p>

<p>
It was also pretty manual.
</p>
</section>
<section id="slide-orgf49d12e">
<h3 id="orgf49d12e">Automating Emacs</h3>
<p>
Emacs has had a batch mode forever (as far as I know, anyway).
</p>

<p>
Clever use of <code>--load</code> and <code>--eval</code> let you turn Emacs into a batch transmogrifier.
</p>
</section>
<section id="slide-org7f58b2e">
<h4 id="org7f58b2e">Why Emacs 30?</h4>
<p>
Emacs 30 lets you use a shebang to treat eshell just like any other shell script.
I thought this was going to be useful, but it turned out not to be.
But if you wondered why this container was built on Debian testing (in September 2025), "Emacs 30" is the answer.
</p>
</section>
<section id="slide-org41ae1b3">
<h3 id="org41ae1b3">Automating artifact generation</h3>
<p>
In essence all you need to do for Reveal.js is to ensure that org-reveal-mode is available.
For PDF output you need LaTeX and an org-mode new enough to support LaTeX output.
</p>

<p>
Then you just call the appropriate export function once you've loaded your org document into the buffer.
</p>
</section>
<section id="slide-org4da87cb">
<h3 id="org4da87cb">Ensuring you have that support</h3>
<p>
The problem is, no one's CI runner is going to have Emacs with a new org-mode and org-reveal preloaded.
</p>

<p>
The obvious thing to do is to build a container with Emacs and a LaTeX setup and run it via Docker (or podman).
</p>

<p>
And the great news is, this has already been (mostly) done by <a href="https://gitlab.com/olberger/docker-org-teaching-export">Olivier Berger</a>.
</p>
</section>
<section id="slide-org0ee8f87">
<h4 id="org0ee8f87">Differences from Berger's work</h4>
<p>
Berger uses Emacs with X enabled, because he prefers those fonts, and goes to some trouble to avoid running Emacs in batch mode.
I don't care: I just get Verdana into the container and set up my PDF export to use it.
</p>

<p>
I don't care about "plain" HTML export&#x2013;if I am exporting to HTML, what I want is Reveal.js.
</p>

<p>
I go a little farther and create a GitHub Actions workflow to allow publication straight to GitHub Pages.
</p>
</section>
<section id="slide-orgd09d251">
<h4 id="orgd09d251">GitHub Action integration</h4>
<p>
The trick here is getting both local builds and GitHub Actions to work correctly and cache built containers.
</p>

<p>
In <a href="./assets/ci.yaml">the GitHub CI YAML</a> you will see that the Docker <code>Build container</code> step caches to and from GHA, and also uses <code>--load</code> to make the image available to susbsequent steps.
</p>

<p>
In <a href="./assets/Makefile">the Makefile</a> the <code>docker-container</code> target tries to use the target container to run a trivial command; if it fails it builds that container.
</p>

<p>
That ensures that, if building locally, you build the container (which is never pushed) unless it's already in your local Docker environment.
If building via GitHub Actions, you will at that point have the container because it will have been built or retrieved from cache and then stored in Docker by <code>Build container</code>.
</p>
</section>
<section id="slide-orgc6d1417">
<h3 id="orgc6d1417">PDF Export</h3>
<p>
Generating PDF output from org-mode is straightforward, at least in the sense that generating LaTeX from org-mode is easy.
</p>

<p>
In theory, once you have a working LaTeX installation, generating a PDF from that is easy.
In practice, that "once you have" is doing a lot of load bearing.
Fortunately, this is what containerization is for.
</p>

<p>
Don't look at <a href="./assets/fix-texlive.bash">how to fix up the installed TeX</a>.
</p>

<p>
On the bright side, <a href="./example.pdf">the PDF version</a> looks OK.
</p>
</section>
<section id="slide-orgc9b3517">
<h3 id="orgc9b3517">Source Code</h3>
<p>
This project lives at <a href="https://github.com/athornton/export-org">GitHub</a>.
</p>

<p>
I may at some point make it into a template project, but for now, all you really need to do is clone it and then replace the org document with your own.
Fix up the <code>Makefile</code> and modify the CSS as you like, and then <code>make site</code> (which is also used as the CI check) will do the trick.
</p>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/reveal.js/dist/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
slideNumber: "h/v",

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'https://cdn.jsdelivr.net/npm/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]

});

</script>
</body>
</html>
